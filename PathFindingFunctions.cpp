//Josh Stone JStone3
#include "PathFindingFunctions.h"
//Function used to check whether the goal has been reached.
bool CheckFinish(SCoords* currentNode, int x, int y)
{
	if (x == currentNode->x && y == currentNode->y)
	{
		return true;
	}
	else
	{
		return false;
	}
}
//Function used to search a list for a specific value.
//Returns true if node is on list. If node isn't on list then returns false.
bool FindValue(deque <unique_ptr < SCoords > > &list, SCoords n)
{
	for (auto p = list.begin(); p != list.end(); p++)
	{
		if ((*p)->x == n.x && (*p)->y == n.y)
		{
			return true;
		}
	}
	return false;
}
//Function used to search closed list and check whether a node has already been visited/generated.
//This function is used in the event that we find a cheaper route of reaching a specific node.
//If this is true then we update the node using the new values and add it to the open list.
void FindValueRemove(deque <unique_ptr < SCoords > > &closedList, SCoords n, deque <unique_ptr < SCoords > > &openList)
{
	unique_ptr < SCoords > temp(new SCoords);
	auto p = closedList.begin(); // set p to the beginning of the loop
	while (p != closedList.end()) // while not at the end of the loop
	{
		if ((*p)->x == n.x && (*p)->y == n.y)
		{
			temp->x = (*p)->x;
			temp->y = (*p)->y;
			temp->cost = (*p)->cost;
			temp->pParent = (*p)->pParent;
			temp->score = (*p)->score;
			openList.push_front(move(temp));
			p = closedList.erase(p);
		}
		else
		{
			p++; //Advance through the loop
		}
	}
}
//Function used to add a new node to the open list.
void InsertNode(deque <unique_ptr < SCoords > > &openList, SCoords node)
{
	unique_ptr<SCoords> temp(new SCoords);
	temp->x = node.x;
	temp->y = node.y;
	temp->cost = node.cost;
	temp->pParent = node.pParent;
	temp->score = node.score;
	openList.push_front(move(temp));
}
//Function used to calculate the hueristic of a node. The heuristic is the absolute distance from the end to a node measured square by square.
int HeuristicCalc(SCoords mapEnd, SCoords n)
{
	int x, y;
	//The heuristics are calcualted for both the x and y axis.
	x = mapEnd.x - n.x;
	y = mapEnd.y - n.y;
	//Both values are then checked if they are below 0. If the values are negative then they are multiplied by -1 to make them positive.
	//Negative values wouldn't give us the absolute distance.
	if (x < 0)
	{
		x *= -1;
	}
	if (y < 0)
	{
		y *= -1;
	}
	return x + y;
}
//Function used in the sorting algorithm to sort the list by score from lowest to highest.
//Returns true or false based on which score is higher.
bool CompareCoords(unique_ptr<SCoords>& lhs, unique_ptr<SCoords>& rhs)
{
	return lhs->score < rhs->score;
}
//Function used to generate the new nodes using the current node from the open list.
void GenerateNodes(SCoords &north, SCoords &east, SCoords &south, SCoords &west, SCoords* currentNode)
{
	north = { currentNode->x, currentNode->y + 1 };//To generate north we add 1 to the y value.
	east = { currentNode->x + 1, currentNode->y };//To generate east we add 1 to the x value.
	south = { currentNode->x, currentNode->y - 1 };//To generate south we subtract 1 from the y value.
	west = { currentNode->x - 1, currentNode->y };//To generate west we subtract 1 from the x value.
}
//Function used to check if a node is already on the open or the closed list and then return the cost of that node.
//This will be used to determine whether to update the values of a node if it has already been visited.
int GetCost(deque <unique_ptr < SCoords > > &openList, deque <unique_ptr < SCoords > > &closedList, SCoords node)
{
	for (auto p = openList.begin(); p != openList.end(); p++)
	{
		if ((*p)->x == node.x && (*p)->y == node.y)
		{
			return (*p)->cost;
		}
	}
	for (auto p = closedList.begin(); p != closedList.end(); p++)
	{
		if ((*p)->x == node.x && (*p)->y == node.y)
		{
			return (*p)->cost;
		}
	}
}
//Function used to calculate the path from start to finish. This function evaluates each node and if a node is valid then it is added to openList.
void CalculatePath(SCoords* currentNode, int mapArray[10][10], int newCost, int existingCost, SCoords node, SCoords mapEnd,
	deque <unique_ptr < SCoords > > &openList, deque <unique_ptr < SCoords > > &closedList)
{
	int wallCost = 0;//Cost of moving to a wall is 0. We use this to ensure that if a generated node is a wall then it is discarded.
	int arrayOffset = 9;//An offset is needed for the array because a 2 dimensional array starts from the top left but the map coordinate system starts in the bottom right.
	existingCost = GetCost(openList, closedList, node);//This is used to store the existing cost of the newly generated node if it is already on open or closed list.
	newCost = currentNode->cost + mapArray[arrayOffset - node.y][node.x];//newCost is the cost of the new node generated by adding the terrain cost of the new node to the cost of its parent,
																		 //in this case the current node.
	if (mapArray[arrayOffset - node.y][node.x] != wallCost)//This check is used to ensure that any nodes that happen to be walls are not added to the lists because we cannot move through walls.
	{
		//We then check to see if the newly generated node is already on the open or closed lists 
		//and if its new cost is greater than the cost of the node on the list then the new node is discarded.
		if ((FindValue(openList, node) || FindValue(closedList, node)) && newCost >= existingCost)
		{
			return;
		}
		else
		{
			node.pParent = currentNode;//We set the parent of the new node to the current node to allow us to create a route by following the parent chain.
			node.score = newCost + HeuristicCalc(mapEnd, node);
			node.cost = newCost;
			//We then check to see if the new node is on open or closed list.
			if (FindValue(openList, node) || FindValue(closedList, node))
			{
				//If the value is on the closed list then we need to remove it from the closed list and add the new value to open list.
				if (FindValue(closedList, node))
				{
					FindValueRemove(closedList, node, openList);
				}
			}
			//We then check if the value isnt on either list. If it isn't then we add it to open list as it is a node that hasn't previously been generated.
			if (!FindValue(openList, node) || !FindValue(closedList, node))
			{
				InsertNode(openList, node);
			}
		}
	}
}
//Function used to move through the chain of parents and create the route from start to end for the map.
void GenerateRoute(deque <unique_ptr < SCoords > > &openList, vector<int> &routeX, vector<int> &routeY, ofstream &outfile, EMaps map, SCoords mapEnd)
{
	SCoords *path;//Pointer variable that will be used to advance through the parents of each node in the final path.
	path = openList.back().get();//Path is set to the back of open list as this is where the end node is placed.
								 //Check used to stop moving along the parent chain as the start nodes parent is set to 0.
	while (path != 0)
	{
		//We push the x and y values of point along the route onto 2 vectors. 1 stores the x values and 1 stores the y values.
		routeX.push_back((*path).x);
		routeY.push_back((*path).y);
		path = path->pParent;//This is used to advance along the parent chain.
	}
	//After we have put the route into the vectors we need to reverse the vectors because we start reading the parent chain from the end point but we want to output the route from the start point.
	reverse(routeX.begin(), routeX.end());
	reverse(routeY.begin(), routeY.end());
	//We then output the routes into the output file.
	if (map == mMap)
	{
		outfile << "mMap " << endl;
		for (int i = 0; i != routeX.size(); i++)
		{
			outfile << routeX[i] << " " << routeY[i] << endl;
		}
		cout << "mMap complete" << endl;
	}
	else if (map == dMap)
	{
		outfile << "dMap " << endl;
		for (int i = 0; i != routeX.size(); i++)
		{
			outfile << routeX[i] << " " << routeY[i] << endl;
		}
		cout << "dMap complete" << endl;
	}
	outfile.close();
}
//Function used to read in files and store information in appropriate variables.
void ReadFiles(ifstream& infile, string SCoordsName, SCoords& start, SCoords& end, string mapName, int mapArray[10][10])
{
	//Read in file containing start and end poin of map.
	infile.open(SCoordsName);
	//Error check incase input file cannot be found.
	if (!infile)
	{
		cout << "ERROR: ";
		cout << "Can't open input file\n";
	}
	while (!infile.eof())
	{
		infile >> start.x >> start.y;
		infile >> end.x >> end.y;
	}
	infile.close();
	//Read in file containing terrain costs of map.
	infile.open(mapName);
	if (!infile)
	{
		cout << "ERROR: ";
		cout << "Can't open input file\n";
	}
	while (!infile.eof())
	{
		for (int i = 0; i < 10; i++)
		{
			for (int j = 0; j < 10; j++)
			{
				infile >> mapArray[i][j];
				///open the file and put in the and then the new coordinates that we generate will relate to a positon in the array
			}							//and this will allow us to get the cost of that square.		
		}
	}
	infile.close();
}
//Function used to set up open list and push start point onto the list.
void InitialiseList(SCoords mapStart, SCoords mapEnd, deque <unique_ptr < SCoords > > &openList, int &newCost, int &existingCost)
{
	int heuristic = HeuristicCalc(mapEnd, mapStart);
	unique_ptr<SCoords> temp(new SCoords);
	temp->x = mapStart.x;
	temp->y = mapStart.y;
	temp->score = heuristic;
	temp->pParent = 0;//Parent set to 0 so that we know when to stop advancing through the parent chain when creating the route.
	temp->cost = 0;
	openList.push_back(move(temp));
	//These variables are then reset.
	newCost = 0;
	existingCost = 0;
}
//Function used to tie together whole program and allow us to use a single function to invoke an A Star search.
void PathFind(bool goalReached, deque <unique_ptr < SCoords > > &openList, deque <unique_ptr < SCoords > > &closedList, SCoords mapEnd, SCoords &north, SCoords &east, SCoords &south, SCoords &west
	, int mapArray[10][10], int newCost, int existingCost)
{
	unique_ptr<SCoords> currentNode(new SCoords);
	while (!goalReached || openList.empty())
	{
		currentNode.reset(new SCoords);//Reset the current node every loop because we move current node onto closed list at the end of every loop.
		currentNode = move(openList.front());//We then set current node to the first value on open list and pop the value from open list.
		openList.pop_front();
		if (CheckFinish(currentNode.get(), mapEnd.x, mapEnd.y))//Check if the end goal has been reached. If it has then we exit the loop after dispalying an end message.
		{
			cout << "Goal reached." << endl;
			openList.push_back(move(currentNode));//We then push the final node back onto open list so we can move through it's parent chain.
			system("pause");
			return;
		}
		//If the current node isn't the end goal then we generate new nodes.
		else
		{
			GenerateNodes(north, east, south, west, currentNode.get());
			//Then we check if the nodes have already been visited by checking openlist, if they haven't then we insert them. 
			CalculatePath(currentNode.get(), mapArray, newCost, existingCost, north, mapEnd, openList, closedList);
			CalculatePath(currentNode.get(), mapArray, newCost, existingCost, east, mapEnd, openList, closedList);
			CalculatePath(currentNode.get(), mapArray, newCost, existingCost, south, mapEnd, openList, closedList);
			CalculatePath(currentNode.get(), mapArray, newCost, existingCost, west, mapEnd, openList, closedList);
			closedList.push_back(move(currentNode));
		}
		//The list is then sorted based on score from lowest to highest.
		sort(openList.begin(), openList.end(), CompareCoords);
	}
}